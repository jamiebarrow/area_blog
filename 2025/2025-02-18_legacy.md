### Rebuilding a Legacy

Software is often compared to building a house, but this analogy falls short because software constantly evolves. A garden is a better metaphor - some plants thrive in shade, others in sunlight, and bugs and weeds must constantly be managed.

Legacy systems often struggle with performance, security, and privacy. Modernizing these systems by adopting contemporary frameworks and languages can address these challenges. Let’s explore why modernization is crucial.

### Motivating Factors

"Legacy" can be seen in two ways:
- **Negative**: Old and outdated
- **Positive**: Something inherited from the past, a heritage

Legacy systems are often responsible for a company’s past success and shouldn’t be dismissed. However, what worked before may not ensure future success. Positive change only comes about through action. You can't predict the future, however the next five years will be exactly like the last five unless something changes.

Environmental changes can also demand adaptation. Crops grow best under specific conditions, and farmers must enrich the soil or rotate crops for a good harvest. Similarly, software engineers must enhance their systems to handle modern requirements, such as scaling or performance improvements.

Upskilling employees is often more cost-effective than losing their knowledge to the market and having to replace them. Just as enriching existing software may be better than rebuilding it. However, if a system is fundamentally flawed, replacement may be the only option.

### The Landscape

A legacy application might evoke thoughts of systems from the ’80s, written in C/C++, COBOL, or Fortran. But for many modern developers, even Java or .NET Framework might seem outdated.

Legacy systems can be identified by several factors:

- **Observability**: Difficulty collecting or analyzing metrics, or noise filled logs hindering diagnosis.
- **System Performance**: Slow load and response times.
- **Security**: Vulnerabilities and errors caused by outdated memory management.
- **Platform Dependence**: Systems tied to obsolete hardware or software require re-platforming.
- **Operational Costs**: High costs can weigh down a business.
- **Maintainability**: Long delays in development and fixes.
    - **Readability**: Complex, hard-to-understand code.
    - **Writability**: Slow development due to technical debt or insufficient knowledge.

### Modern Platforms

Legacy systems tied to specific hardware, such as COBOL systems, often need migration when hardware becomes obsolete. Java, Docker, and Kubernetes have thrived due to platform independence, enabling a "write once, run anywhere" approach that reduces costs and eases maintenance. This flexibility is also a driving factor of the popularity of Python, C# and JavaScript.

Many industries, especially banking and government, still rely on COBOL but adopt Java for new systems to leverage existing skills. Yet, technology choice is just one piece of the puzzle. Good system design, clear documentation, and maintainability are more crucial for simplifying complex, legacy processes.

Meanwhile, cloud computing and tools like Bicep and Terraform have streamlined environment provisioning. Standardized APIs and evolving integration patterns accelerate development, though they can increase complexity in today’s interconnected systems.

The modern landscape isn’t just a garden, but a rich, interconnected forest - an ecosystem.

### Necessity is the mother of invention

Innovation often arises from necessity, as seen during the COVID-19 pandemic where businesses had to rapidly adapt to remote work. Keeping with the gardening analogy, a garden thrives only when it’s nurtured and adapted to changing conditions. In software development, technical debt accumulates when systems aren’t maintained and often is left unaddressed until it causes problems.

Businesses may be reluctant to make changes until forced by external pressures, just as gardeners might wait until plants show signs of distress before adjusting soil or irrigation. However, those who proactively tend to their systems by updating frameworks and refactoring code are better prepared to thrive in the long run, much like a well-maintained garden that flourishes with careful, ongoing attention.

### Where to focus

The key to identifying what to focus on, is deciding what to measure. If you believe clients are happy then this is only a hypothesis until it is proven by market research. Data analysis is a big trend these days, because without data, all ideas and proposals are just that - subjective ideas. The scientific method is to form a hypothesis, run a repeatable experiment, analyze the data from this experiment and finally come to a more objective conclusion.

### Experiments

Perhaps one of the feedback items coming back from clients is that the system is slow. It doesn't perform well. In order to measure this, you could do a variety of measurements:

- **Maintainability test:** Gathering metrics on the existing code could highlight problematic areas
- **Performance test:** Measure the time taken for every API endpoint and for every database query
- **User Experience test:** Measure the number of actions and wait times of a user performing a task
- **A/B test:** Split your users into two groups, A and B, with two different experiences during a specific period of time. Capture feedback to gather whether A or B gains higher user satisfaction

### Performance

For measuring an API endpoint, you could use tools such as Apache JMeter or Grafana k6 to simulate a period of load in the system. [Load tests](https://grafana.com/docs/k6/latest/testing-guides/test-types/#different-tests-for-different-goals) are explained nicely in the k6 documentation:

- Smoke tests - minimal load.
- Average-load tests - expected normal conditions.
- Soak tests - assess the reliability over extended periods of average-load.
- Stress tests - push the system to its limits.
- Spike tests - sudden, short, and massive increases in activity are often challenging.
- Breakpoint tests - see just how far you can push before it breaks.

If you receive feedback from clients that the system is slow, but you test the system yourself and see that it performs as expected, then perhaps you are experiencing the system under an average-load. The clients reporting slow performance are likely in scenarios where there is a spike in usage or a stress on the system which could also be evidenced by more frequent application timeouts.

Performing a scale-up of your systems could mitigate or even resolve these issues during a period high load. This could incur extra costs, but this may be justified for the business to cater its client base. Scaling down these systems as soon as system load returns back to a normal state can then also help to reduce unnecessary costs. Having this kind of proactive monitoring in place and high observability could then confirm client experiences and focus on where to improve.

### User Experience

You can monitor real clients and see how they perform actions throughout your system. Products such as [Hotjar](https://www.hotjar.com/product/heatmaps/) provide solutions for seeing heatmaps and session recordings as clients interact with your website. [Google Analytics Events](https://developers.google.com/analytics/devguides/collection/ga4/events) are another useful tool to monitor the use of a system. These could integrate with other metrics from marketing teams for example to see the success of a marketing campaign leading to a user signup and call to action leading to a successful sale.

This also comes with privacy concerns, as most people feel uncomfortable being monitored. A solution to this being bringing in a control group, perhaps even two control groups to do A/B testing of improvements to the system. Like a wine farmer giving a blind taste test of two different blends to see which product to take to market.

### Maintainability

There are various tools and metrics for maintainability:
- Static analysis of cyclomatic complexity
- Unit test code coverage reports
- Static analysis tools for known issues and code conventions - e.g. EditorConfig, Checkstyle, SonarQube, eslint, etc.

An interesting tool I came across in recent times is [CodeCharta](https://codecharta.com/docs/analysis/metrics) which can allow you to view your codebase as a city map. The aim being to make it more tangible and intuitive in finding hotspots to tackle. This again shows the value of visualizing data.

They have a good document on code [Metrics](https://codecharta.com/docs/analysis/metrics), with one very valuable point:

> When a metric becomes a target, it ceases to be a good metric. – Free interpretation of [Goodhearts Law](https://en.wikipedia.org/wiki/Goodhart%27s_law)

Another law is also useful in this case, the Law of Diminishing Returns, where at some point despite putting in extra effort of improving maintainability, you'll start to get less and less value out of your efforts.

### Maintainability > Code

When you talk about maintainability of a system, often the applications and the code thereof is thought about. However, documentation is also an artifact of a system. Knowledge of how a process works, is part of the business.

You may be able to document knowledge using Word or Sharepoint. Perhaps using tools such as Markdown and Asciidoc as a source, which could be later published as Word or PDF documents, or even automatically integrated with a Confluence or Sharepoint portal.

An example of improvement here is calculating the average reading time of an article.
- [Medium - Read time](https://help.medium.com/hc/en-us/articles/214991667-Read-time)

### Business > software

Software systems are likely just business processes that have been automated. In the past, you would have had to go to a bank clerk to transfer money between your accounts. Today, this is automated and can usually be done using an app on your mobile phone.

The various rules, policies, laws and other business related aspects of this are in fact what are important.

> Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.
> -- Conway's Law

If you have a complex business process, then likely your system will also end up being complex.
If you wish to simplify your software systems, most likely you also need to understand your current business processes, and see how they can be simplified first.

After all, software is a legacy but the value brought from a business is its heritage.
