# Rebuilding a Legacy

Software is often compared to building a house, but this analogy falls short — software constantly evolves.
A garden is a better metaphor.
Some plants thrive in shade, others in sunlight, and bugs and weeds must constantly be managed.

Legacy systems often struggle with performance, security, and privacy.
Modernizing these systems by adopting contemporary frameworks and languages can help address these challenges.
Let’s explore why modernization is crucial.

## Motivating Factors

"Legacy" can be seen in two ways:
- **Negative:** Old and outdated
- **Positive:** A heritage that has contributed to past success

While legacy systems may have been the foundation for a company's achievements, what worked before may no longer guarantee future success.
Positive change requires taking action.
You can't predict the future, but the next five years will likely mirror the past unless you take steps to change.

Environmental shifts also demand adaptation.
Crops need specific conditions to thrive, and farmers must rotate them to maintain healthy soil.
Similarly, software engineers must evolve their systems to handle modern requirements like scaling or performance improvements.

Upskilling employees can be more cost-effective than replacing them, just as enhancing existing software may be more practical than rebuilding it.
However, if a system is fundamentally flawed, replacement might be the only option.

## The Landscape

A legacy application might evoke thoughts of systems from the ’80s, written in C/C++, COBOL, or Fortran.
However, even Java or .NET Framework might feel outdated to modern developers.

Legacy systems often exhibit:

- **Observability issues:** Difficulty analyzing metrics or noisy logs
- **Performance problems:** Slow load and response times
- **Security concerns:** Vulnerabilities from outdated memory management
- **Platform dependence:** Systems tied to obsolete hardware or software
- **High operational costs:** Place a burden on the business
- **Poor maintainability:** Complex, hard-to-understand code leads to slow development and fixes

## Modern Platforms

Legacy systems, particularly those tied to specific hardware (like COBOL), often require migration when that hardware becomes obsolete.
Java, Docker, and Kubernetes have thrived due to their platform independence, enabling a "write once, run anywhere" approach that reduces costs and simplifies maintenance.
Flexibility also drives the popularity of Python, C#, and JavaScript.

Many industries, especially banking and government, still rely on COBOL but adopt Java for newer systems, leveraging existing skills.
However, the technology choice is just one piece.
Good system design, clear documentation, and maintainability are more important for simplifying complex, legacy processes.

Cloud computing and tools like Bicep and Terraform streamline environment provisioning, while standardized APIs and evolving integration patterns accelerate development, though they can increase complexity in today’s interconnected systems.

The modern landscape isn’t just a garden.
It is a rich, interconnected forest — an ecosystem.

## Necessity is the Mother of Invention

Innovation often arises from necessity.
During the COVID-19 pandemic, businesses rapidly adapted to remote work.
Much like a garden thrives when nurtured and adapted to changing conditions, software systems require ongoing attention to avoid accumulating technical debt.

Businesses may hesitate to make changes until external pressures force them to.
However, those who proactively update frameworks and refactor code are better prepared to thrive in the long run.
Like a well-maintained garden flourishing with care.

## Where to Focus

To identify areas for improvement, decide what to measure. If you believe clients are happy, this is a hypothesis that must be validated through market research.
Data analysis is key.
Without data, ideas and proposals remain subjective.
Use the scientific method: form a hypothesis, run an experiment, analyze the results, and draw objective conclusions.

## Experiments

Feedback may indicate that your system is slow or that teams are slow to assist with client requests.
To measure this, you can perform various tests:

- **Performance Test:** Measure API endpoint and database query times
- **User Experience Test:** Track the number of actions and wait times during user tasks
- **A/B Test:** Split users into two groups, A and B, with different experiences, to gauge satisfaction
- **Maintainability Test:** Analyze metrics on code health

## Performance

For API performance, tools like Apache JMeter or Grafana k6 can simulate load on your system. Load tests include:

- Smoke tests: Minimal load
- Average-load tests: Normal conditions
- Soak tests: Reliability over extended periods
- Stress tests: Pushing the system to its limits
- Spike tests: Short, massive increases in activity
- Breakpoint tests: Finding the breaking point

If clients report slow performance but tests show that the system performs as expected, they may be experiencing spikes in load or stress, resulting in timeouts.
Scaling up during high demand and scaling down afterward can help balance performance and costs.
Proactive monitoring and observability confirm the client experience and guide improvements.

## User Experience

Monitor real clients and analyze their interactions with your system, or in the case of privacy concerns undertake these with a control group.
Tools like [Hotjar](https://www.hotjar.com/product/heatmaps/) provide heatmaps and session recordings, while [Google Analytics Events](https://developers.google.com/analytics/devguides/collection/ga4/events) can track user actions.
Ensure you implement controls like A/B testing to gain objective feedback on system improvements.

## Maintainability

Use tools and metrics to improve maintainability:

- Static analysis for cyclomatic complexity
- Unit test code coverage reports
- Static analysis with tools like EditorConfig, Checkstyle, SonarQube, and eslint

An interesting tool is [CodeCharta](https://codecharta.com/docs/analysis/metrics), which visualizes your codebase as a city map to help you spot problematic areas.

Keep in mind: “When a metric becomes a target, it ceases to be a good metric” (Goodhart’s Law).
Similarly, the Law of Diminishing Returns means that after a certain point, additional efforts to improve maintainability yield diminishing returns.

## Maintainability > Code

Maintainability isn’t just about code; it also includes documentation.
Understanding how a process works and capturing that knowledge is vital for the business.
Tools like Markdown, Asciidoc, and Confluence can facilitate creating and managing this documentation.
You can also calculate average reading times for documents, such as using [Medium’s read time](https://help.medium.com/hc/en-us/articles/214991667-Read-time) algorithm to improve reader engagement with your documentation.

## Business > Software

Software systems automate business processes.
In the past, transferring money between bank accounts required a clerk, but today it’s done via a mobile app.
Business rules, policies, and laws form the foundation of a software system.
Conway’s Law suggests that the design of an organization’s software often mirrors its communication structures.
Therefore, simplifying software often requires simplifying the underlying business processes.

After all, software is a legacy but the value brought from a business is its heritage.
