# Rebuilding a Legacy

Software is often compared to building a house, but this analogy falls short - software constantly evolves. A garden is a better metaphor. Some plants thrive in shade, others in sunlight, and bugs and weeds must constantly be managed.

Legacy systems often struggle with performance, security, and privacy. Modernizing these systems by adopting contemporary frameworks and languages can help address these challenges.

With ShareValue taking care of your software systems, you can focus on growing your business, knowing that your digital garden is in expert hands. Let's explore why modernization is crucial.

## Motivating Factors

"Legacy" can be seen in two ways:

- **Negative:** Old and outdated
- **Positive:** A heritage that has contributed to past success

While legacy systems may have been the foundation for a company's achievements, what worked before may no longer guarantee future success. Positive change requires taking action. You can't predict the future, but the next five years will likely mirror the past unless you take steps to change.

Environmental shifts also demand adaptation. Crops need specific conditions to thrive, and farmers must rotate them to maintain healthy soil. Similarly, software engineers must evolve their systems to handle modern requirements like scaling or performance improvements.

Upskilling employees can be more cost-effective than replacing them, just as enhancing existing software may be more practical than rebuilding it. However, if a system is fundamentally flawed, replacement might be the only option.

## The Landscape

A legacy application might evoke thoughts of systems from the '80s, written in C/C++, COBOL, or Fortran. However, even Java or .NET Framework might feel outdated to modern developers.

Legacy systems often exhibit:

- **Observability issues:** Difficulty analyzing metrics or noisy logs
- **Performance problems:** Slow load and response times
- **Security concerns:** Vulnerabilities from outdated memory management
- **Platform dependence:** Systems tied to obsolete hardware or software
- **High operational costs:** Place a burden on the business
- **Poor maintainability:** Complex, hard-to-understand code leads to slow development and fixes

## Modern Platforms

Legacy systems tied to specific hardware (e.g. COBOL) often require migration when that hardware becomes obsolete. Java, Docker, and Kubernetes have thrived due to their platform independence, enabling a "write once, run anywhere" approach that reduces costs and simplifies maintenance. Flexibility also drives the popularity of Python, C#, and JavaScript.

Many industries, especially banking and government, still rely on COBOL but adopt Java for newer systems, leveraging existing skills. However, the technology choice is just one piece. Good system design, clear documentation, and maintainability are more important for simplifying complex, legacy processes.

Cloud computing and tools like Bicep and Terraform streamline environment provisioning, while standardized APIs and evolving integration patterns accelerate development, though they can increase complexity in today's interconnected systems.

The modern landscape isn't just a garden. It is a rich, interconnected forest - an ecosystem.

## Necessity is the Mother of Invention

Innovation often arises from necessity. During the COVID-19 pandemic, businesses rapidly adapted to remote work. Much like a garden thrives when nurtured and adapted to changing conditions, software systems require ongoing attention to avoid accumulating technical debt.

Businesses may hesitate to make changes until external pressures force them to. However, those who proactively update frameworks and refactor code are better prepared to thrive in the long run.
Like a well-maintained garden flourishing with care.

## Where to Sow the Seeds

To identify areas for improvement, first decide what to measure. If you believe clients are happy, this is a hypothesis that must be validated through market research. If you believe a business process is inefficient, how do you know making a change will improve performance?

Data analysis is key. Without data, ideas and proposals remain subjective. Use the scientific method: form a hypothesis, run an experiment, analyze the results, and draw objective conclusions.

## Field Trials and Experiments

Feedback may indicate that your system is slow or that teams are slow to assist with client requests. To measure this, you can perform various tests:

- **Performance Test:** Measure API endpoint and database query times
- **User Experience Test:** Track the number of actions and wait times during user tasks
- **A/B Test:** Split users into two groups, A and B, with different experiences, to gauge satisfaction
- **Maintainability Test:** Analyze metrics on code health
- **Security test:** Attempt known security attack vectors to ensure system integrity and identify any potential vulnerabilities

## Harvesting Insights

Monitor interactions within your systems. Tools like [Hotjar](https://www.hotjar.com/product/heatmaps/) provide heatmaps and session recordings, while [Google Analytics Events](https://developers.google.com/analytics/devguides/collection/ga4/events) can track user actions. In case of privacy concerns by users, these can be done within a control group. Implementing experiments such as A/B testing allows gaining objective feedback on system improvements.

## Barometers and Rain Gauges

Environmental measurements guide the growth of a garden, just as observability can guide software performance optimization. API performance of different scenarios can be gauged with tools such as [Apache JMeter](https://jmeter.apache.org/) or [Grafana k6](https://k6.io/) through [various load tests](https://grafana.com/docs/k6/latest/testing-guides/test-types/#different-tests-for-different-goals) to simulate these scenarios in your system:

- **Smoke tests:** Minimal load
- **Average-load tests:** Normal conditions
- **Soak tests:** Reliability over extended periods
- **Stress tests:** Pushing the system to its limits
- **Spike tests:** Short, massive increases in activity
- **Breakpoint tests:** Finding the breaking point

Analyzing the application and system logs over certain periods can yield valuable insights, especially using techniques such as structured logging from frameworks such as [NLog](https://nlog-project.org/) or [Serilog](https://serilog.net/) in .NET. There are a multitude of vendors offering advanced analysis products based on collected data:

- [Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/) with [Azure Application Insights](https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)
- [Splunk](https://www.splunk.com/en_us/products/observability.html)
- [DataDog](https://www.datadoghq.com/product/observability-pipelines/)

The right load test could verify user feedback, e.g. experiencing spikes in load or a stressed system may result in timeouts. Scaling up during high demand and scaling down afterward can help balance performance and costs. Proactive monitoring and observability could perhaps mitigate the issue before client notice the system degradation. Advanced analysis of user behaviour could even identify attempts of malicious users to exercise security attack vectors.

## Keep out the foxes and bugs

A farmer protects his livestock from being hunted by foxes. A gardener tries to keep out infestations of bugs that destroy his crops.

Legacy systems are particularly vulnerable to security risks, as outdated frameworks and languages become prime targets for cyberattacks. Modern programming languages like Kotlin, Rust, and C# help address these challenges by focusing on safety and minimizing common errors, preventing vulnerabilities often found in older systems.

Newer versions of C# (starting with C# 8.0) introduce nullable reference types, which may prevent null reference exceptions, a frequent cause of runtime errors that can make code difficult to debug and maintain. For observability and operations teams, these exceptions can clutter logs and complicate root cause analysis. Modern C# reduces the risk of these issues, enhancing security, maintainability, and operational efficiency.

Kotlin offers similar benefits regarding null safety. In addition, Kotlin's concise syntax, enhanced concurrency handling, and strong integration with Java make it an excellent choice for modernizing Java-based systems. This reduces the risks associated with error-prone code while improving code quality.

Rust emphasizes memory safety without relying on a garbage collector. It prevents issues such as buffer overflows, memory leaks, and dangling pointers at compile time. These help high-performance systems remain secure and reliable, which is especially important in security-critical environments such as blockchain and IoT. Rust's strict ownership rules and compile-time memory management help mitigate many vulnerabilities common in older systems programming languages like C and C++.

By adopting the latest features of modern programming languages, businesses can significantly reduce security vulnerabilities, streamline system maintenance, and improve overall observability, resulting in more secure, maintainable, and future-proof systems. And perhaps happier development teams.

## Pruning and Upkeep

Flourishing grape vines and other creepers are beautiful to look at, until they grow out of hand. They could suffocate other plants and even damage the walls of buildings they cling to. Regular pruning is necessary to sustain balance and avoid a tangled mess.

The same is true of software code. Tools can help manage the growing software forests:

- Cyclomatic complexity to minimize complexity
- Unit test code coverage reports to view how much is covered by safety nets for correctness
- Static analysis tools like EditorConfig, Checkstyle, SonarQube, eslint and others ensure standardization and consistency

Another interesting tool is [CodeCharta](https://codecharta.com/docs/analysis/metrics), which visualizes a codebase as a city map. Having a more tangible view in order to assist spotting problematic areas, such as code areas with constantly high code churn, or areas that may have knowledge gaps due to lack of team exposure. 

There are some laws that can be kept in mind here such as the Law of Diminishing Returns, Brooke's Law, Amdahl's Law and Goodhart's Law: When a metric becomes a target, it ceases to be a good metric. After a certain point, additional efforts to improve maintainability do not yield much value, so be wary of investing focus and extra resources if they become counterproductive.

## Managed Ecosystems or Wild Jungles

Software systems automate business processes. In the past, transferring money between bank accounts required a clerk, but today it's done via a mobile app.

Business rules, policies, and laws form the foundation of a software system. Conway's Law suggests that the design of an organization's software often mirrors its communication structures. Therefore, simplifying software often requires simplifying the underlying business processes.

After all, software is a legacy but the value brought from a business is its heritage.

## Care Guides

Maintainability isn't just about code; it also includes documentation. Understanding how a process works and capturing that knowledge is vital for the business. Tools like Markdown, Asciidoc, Confluence and SharePoint can facilitate managing this knowledge and business continuity.

Even here metrics can help. Tools calculating average reading times for documents, such as using [Medium's read time](https://help.medium.com/hc/en-us/articles/214991667-Read-time) algorithm, can improve reader engagement with your documentation.

## Your Trusted Garden Service: ShareValue

Modernizing legacy systems can feel like maintaining a complex ecosystem, with constant care and expertise needed. Instead of tending to your gardens by yourself, ShareValue acts as your trusted garden service, bringing the right tools, knowledge, and experience to nurture your software systems.

From assessing your current landscape to providing ongoing care, we ensure your systems remain secure, scalable, and ready for the future, allowing you to focus on what truly matters: growing your business and leaving behind a legacy of value.
