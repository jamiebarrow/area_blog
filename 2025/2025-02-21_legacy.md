# Rebuilding a Legacy

Software is often compared to building a house, but this analogy falls short — software constantly evolves.
A garden is a better metaphor.
Some plants thrive in shade, others in sunlight, and bugs and weeds must constantly be managed.

Legacy systems often struggle with performance, security, and privacy.
Modernizing these systems by adopting contemporary frameworks and languages can help address these challenges.
Let's explore why modernization is crucial.

## Motivating Factors

"Legacy" can be seen in two ways:
- **Negative:** Old and outdated
- **Positive:** A heritage that has contributed to past success

While legacy systems may have been the foundation for a company's achievements, what worked before may no longer guarantee future success.
Positive change requires taking action.
You can't predict the future, but the next five years will likely mirror the past unless you take steps to change.

Environmental shifts also demand adaptation.
Crops need specific conditions to thrive, and farmers must rotate them to maintain healthy soil.
Similarly, software engineers must evolve their systems to handle modern requirements like scaling or performance improvements.

Upskilling employees can be more cost-effective than replacing them, just as enhancing existing software may be more practical than rebuilding it.
However, if a system is fundamentally flawed, replacement might be the only option.

## The Landscape

A legacy application might evoke thoughts of systems from the '80s, written in C/C++, COBOL, or Fortran.
However, even Java or .NET Framework might feel outdated to modern developers.

Legacy systems often exhibit:

- **Observability issues:** Difficulty analyzing metrics or noisy logs
- **Performance problems:** Slow load and response times
- **Security concerns:** Vulnerabilities from outdated memory management
- **Platform dependence:** Systems tied to obsolete hardware or software
- **High operational costs:** Place a burden on the business
- **Poor maintainability:** Complex, hard-to-understand code leads to slow development and fixes

## Modern Platforms

Legacy systems, particularly those tied to specific hardware (like COBOL), often require migration when that hardware becomes obsolete.
Java, Docker, and Kubernetes have thrived due to their platform independence, enabling a "write once, run anywhere" approach that reduces costs and simplifies maintenance.
Flexibility also drives the popularity of Python, C#, and JavaScript.

Many industries, especially banking and government, still rely on COBOL but adopt Java for newer systems, leveraging existing skills.
However, the technology choice is just one piece.
Good system design, clear documentation, and maintainability are more important for simplifying complex, legacy processes.

Cloud computing and tools like Bicep and Terraform streamline environment provisioning, while standardized APIs and evolving integration patterns accelerate development, though they can increase complexity in today's interconnected systems.

The modern landscape isn't just a garden.
It is a rich, interconnected forest — an ecosystem.

## Necessity is the Mother of Invention

Innovation often arises from necessity.
During the COVID-19 pandemic, businesses rapidly adapted to remote work.
Much like a garden thrives when nurtured and adapted to changing conditions, software systems require ongoing attention to avoid accumulating technical debt.

Businesses may hesitate to make changes until external pressures force them to.
However, those who proactively update frameworks and refactor code are better prepared to thrive in the long run.
Like a well-maintained garden flourishing with care.

## Where to Focus

To identify areas for improvement, decide what to measure. If you believe clients are happy, this is a hypothesis that must be validated through market research.
Data analysis is key.
Without data, ideas and proposals remain subjective.
Use the scientific method: form a hypothesis, run an experiment, analyze the results, and draw objective conclusions.

## Experiments

Feedback may indicate that your system is slow or that teams are slow to assist with client requests.
To measure this, you can perform various tests:

- **Performance Test:** Measure API endpoint and database query times
- **User Experience Test:** Track the number of actions and wait times during user tasks
- **A/B Test:** Split users into two groups, A and B, with different experiences, to gauge satisfaction
- **Maintainability Test:** Analyze metrics on code health
- **Security test:** Attempt known security attack vectors to ensure system integrity and identify any potential vulnerabilities

## User Experience

Monitor real clients and analyze their interactions with your system, or in the case of privacy concerns undertake these with a control group.
Tools like [Hotjar](https://www.hotjar.com/product/heatmaps/) provide heatmaps and session recordings, while [Google Analytics Events](https://developers.google.com/analytics/devguides/collection/ga4/events) can track user actions.
Ensure you implement controls like A/B testing to gain objective feedback on system improvements.

## Performance and Observability

For API performance, tools like [Apache JMeter](https://jmeter.apache.org/) or [Grafana k6](https://k6.io/) can use [various load tests](https://grafana.com/docs/k6/latest/testing-guides/test-types/#different-tests-for-different-goals) to simulate load on your system:

- **Smoke tests:** Minimal load
- **Average-load tests:** Normal conditions
- **Soak tests:** Reliability over extended periods
- **Stress tests:** Pushing the system to its limits
- **Spike tests:** Short, massive increases in activity
- **Breakpoint tests:** Finding the breaking point

You can also analyse the application and system logs over certain periods.
You could use structured logging frameworks such as [NLog](https://nlog-project.org/) or [Serilog](https://serilog.net/) in .NET and analyse these using custom tooling.
These days there are a multitude of vendors offering advanced analysis products based on data collected from various sources, such as:

- [Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/) with
[Azure Application Insights](https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)
- [Splunk](https://www.splunk.com/en_us/products/observability.html)
- [DataDog](https://www.datadoghq.com/product/observability-pipelines/)

If clients report slow performance but tests show that the system performs as expected, they may be experiencing spikes in load or stress, resulting in timeouts.
Scaling up during high demand and scaling down afterward can help balance performance and costs.
Proactive monitoring and observability confirm the client experience and guide improvements.
Advanced analysis of user behaviour could even identify attempts of malicious users to exercise security attack vectors. 

## Improving Security and Reducing Bugs

Legacy systems are particularly vulnerable to security risks, as outdated frameworks and languages become prime targets for cyberattacks.
Modern programming languages like Kotlin, Rust, and C# (in its latest versions) help address these challenges by focusing on safety and minimizing common errors, preventing vulnerabilities often found in older systems.

Newer versions of C# (starting with C# 8.0) introduce nullable reference types, allowing developers to explicitly define when a reference type can be null.
This feature helps prevent null reference exceptions, a frequent cause of runtime errors that can make code difficult to debug and maintain.
For observability and operations teams, these exceptions can clutter logs and complicate root cause analysis.
By making nullability explicit, C# reduces the risk of these issues, enhancing security, maintainability, and operational efficiency.

Kotlin offers similar benefits with its improved null safety.
In addition, Kotlin's concise syntax, enhanced concurrency handling, and strong integration with Java make it an excellent choice for modernizing Java-based systems.
This reduces the risks associated with error-prone code while improving code quality.

Rust, on the other hand, emphasizes memory safety without relying on a garbage collector.
It prevents issues such as buffer overflows, memory leaks, and dangling pointers at compile time, ensuring high-performance systems remain secure and reliable.
This is especially important for security-critical applications like blockchain and IoT.
Rust's strict ownership rules and compile-time memory management help mitigate many vulnerabilities common in older systems programming languages like C and C++.

By adopting the latest features of modern programming languages, businesses can significantly reduce security vulnerabilities, streamline system maintenance, and improve overall observability, resulting in more secure, maintainable, and future-proof systems.

## Maintainability

Use tools and metrics to improve maintainability:

- Cyclomatic complexity
- Unit test code coverage reports
- Static analysis with tools like EditorConfig, Checkstyle, SonarQube, and eslint

An interesting tool is [CodeCharta](https://codecharta.com/docs/analysis/metrics), which visualizes your codebase as a city map to help you spot problematic areas.

Keep two laws in mind, Goodhart's Law and the Law of Dimishing Returns:
When a metric becomes a target, it ceases to be a good metric.
After a certain point, additional efforts to improve maintainability do not yield much value and are not worth the extra effort.

## Maintainability > Code

Maintainability isn't just about code; it also includes documentation.
Understanding how a process works and capturing that knowledge is vital for the business.
Tools like Markdown, Asciidoc, and Confluence can facilitate creating and managing this documentation.
You can also calculate average reading times for documents, such as using [Medium's read time](https://help.medium.com/hc/en-us/articles/214991667-Read-time) algorithm to improve reader engagement with your documentation.

## Business > Software

Software systems automate business processes.
In the past, transferring money between bank accounts required a clerk, but today it's done via a mobile app.

Business rules, policies, and laws form the foundation of a software system.
Conway's Law suggests that the design of an organization's software often mirrors its communication structures.
Therefore, simplifying software often requires simplifying the underlying business processes.

After all, software is a legacy but the value brought from a business is its heritage.
